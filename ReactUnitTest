npm install --save-dev jest @testing-library/react @testing-library/jest-dom





If 
npm test 
Gives no error and 
npx jest 
gives error message. May be babel is not correctly installed:
npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
Create a file named jest.config.js in your project root with:
module.exports = {
  testEnvironment: "jsdom",
  transform: {
    "^.+\\.(js|jsx)$": "babel-jest"
  },
  moduleFileExtensions: ["js", "jsx"],
};
And a file .babelrc in your root folder with:
{
  "presets": ["@babel/preset-env", "@babel/preset-react"]
}






Here’s a complete explanation with examples of all the custom matchers provided by @testing-library/jest-dom — which extends Jest with more intuitive assertions for DOM nodes.

1. toBeDisabled()
Checks if an element is disabled.
expect(button).toBeDisabled();
2. toBeEnabled()
Checks if an element is enabled.
expect(input).toBeEnabled();
3. toBeEmptyDOMElement()
Checks if an element has no children or text content.
expect(div).toBeEmptyDOMElement();
4. toBeInTheDocument()
Checks if an element is present in the DOM.
expect(screen.getByText('Submit')).toBeInTheDocument();
5. toBeInvalid()
Checks if a form element is invalid (.checkValidity() === false).
expect(input).toBeInvalid();
6. toBeRequired()
Checks if an input element has the required attribute.
expect(input).toBeRequired();
7. toBeValid()
Checks if a form element is valid (.checkValidity() === true).
expect(input).toBeValid();
8. toBeVisible()
Checks if an element is visible (not hidden with CSS or attribute).
expect(div).toBeVisible();
9. toContainElement(child)
Checks if a parent DOM node contains a specific child element.
expect(parentDiv).toContainElement(childDiv);
10. toContainHTML(html)
Checks if the element’s innerHTML contains the given HTML snippet.
expect(div).toContainHTML('<span>Test</span>');
11. toHaveAccessibleDescription()
Checks the element’s accessible description (e.g., via aria-describedby).
expect(button).toHaveAccessibleDescription('Click to save');
12. toHaveAccessibleErrorMessage()
Checks the element’s accessible error message (linked by aria-errormessage).
expect(input).toHaveAccessibleErrorMessage('Invalid email');
13. toHaveAccessibleName()
Checks the element’s accessible name (e.g., from aria-label or <label>).
expect(button).toHaveAccessibleName('Submit');
14. toHaveAttribute(attrName, value?)
Checks if an element has a specific attribute and optionally a value.
expect(img).toHaveAttribute('src', 'logo.png');
15. toHaveClass(className)
Checks if the element has a class (or classes).
expect(div).toHaveClass('active');
expect(div).toHaveClass('btn primary');
16. toHaveFocus()
Checks if the element currently has focus.
expect(input).toHaveFocus();
17. toHaveFormValues(obj)
Checks if a <form> has input values matching the provided key-value pairs.
expect(form).toHaveFormValues({
  username: 'john',
  email: 'john@example.com'
});
18. toHaveStyle(css)
Checks if an element has matching inline styles.
expect(div).toHaveStyle('display: flex; color: red');
19. toHaveTextContent(text, options?)
Checks if the element contains specific text (ignores hidden children).
expect(div).toHaveTextContent('Hello World');
20. toHaveValue(value)
Checks the value of an input, select, or textarea.
expect(input).toHaveValue('John');
21. toHaveDisplayValue(value)
Checks the visible displayed value of a form control like <select> or <input>.
expect(select).toHaveDisplayValue('Option A');
22. toBeChecked()
Checks if an input (checkbox/radio) is checked.
expect(checkbox).toBeChecked();
23. toBePartiallyChecked()
Used for indeterminate checkboxes (not fully checked).
expect(checkbox).toBePartiallyChecked();
24. toHaveRole(role, options?)
Checks if an element has a specific ARIA role.
expect(button).toHaveRole('button');
25. toHaveErrorMessage(message)
Checks for accessible error messages (label or aria-related).
expect(input).toHaveErrorMessage('Required field');

Example Setup for Jest-DOM
Install jest-dom if not already:
npm install --save-dev @testing-library/jest-dom
In setupTests.js:
import '@testing-library/jest-dom';






App.js

// App.js
import React, { useState } from "react";

function App() {
  const [name, setName] = useState("");
  const [submitted, setSubmitted] = useState(false);

  const handleSubmit = (e) => {
    e.preventDefault();
    setSubmitted(true);
  };

  return (
    <div>
      <h1>React Form Test</h1>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">Name:</label>
        <input
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          required
        />
        <button type="submit" disabled={!name}>
          Submit
        </button>
      </form>
      {submitted && <p role="alert">Submitted: {name}</p>}
    </div>
  );
}

export default App;









App.test.js

// App.test.js
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import '@testing-library/jest-dom'; // for custom matchers
import App from "./App";

test("input should be empty initially", () => {
  render(<App />);
  const input = screen.getByLabelText(/name/i);
  expect(input).toBeInTheDocument();
  expect(input).toHaveValue(""); // toHaveValue
});

test("submit button should be disabled initially", () => {
  render(<App />);
  const button = screen.getByRole("button", { name: /submit/i });
  expect(button).toBeDisabled(); // toBeDisabled
});

test("submit button should enable after entering name", () => {
  render(<App />);
  const input = screen.getByLabelText(/name/i);
  const button = screen.getByRole("button", { name: /submit/i });

  fireEvent.change(input, { target: { value: "Alice" } });
  // fireEvent is used to simulate user interaction.
  // fireEvent.change simulates the user typing into a form input.
  expect(button).toBeEnabled(); // toBeEnabled
});

test("displays submitted message after submitting form", () => {
  render(<App />);
  const input = screen.getByLabelText(/name/i);
  const button = screen.getByRole("button", { name: /submit/i });
// submit/i means, "Submit", case-insensitive
  fireEvent.change(input, { target: { value: "Alice" } });
  fireEvent.click(button);
  const message = screen.getByRole("alert");
  expect(message).toBeInTheDocument(); // toBeInTheDocument
  expect(message).toHaveTextContent("Submitted: Alice"); // toHaveTextContent
});






HelloWorld.js

import React from "react";

class HelloWorld extends React.Component {
   render() {
      return (
         <div>
            <h1>Hello World!</h1>
         </div>
      );
   }
}
export default HelloWorld;







HelloWorld.test.js

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import HelloWorld from './HelloWorld';

test('test scenario 1', () => {
   render(<HelloWorld />);
   const element = screen.getByText(/Hello World/i);
   expect(element).toBeInTheDocument();
});








Common Jest Functions (with Examples):


1. test() / it()
Defines a test case.
test("2 + 2 should be 4", () => {
  expect(2 + 2).toBe(4);
});
it("returns true when active", () => {
  expect(true).toBeTruthy();
});

2. expect()
Performs assertions.
expect(value).toBe(expected);       // primitive comparison
expect(obj).toEqual(expectedObj);   // deep comparison for objects
expect(fn).toThrow();  

3. Mock Functions
const mockFn = jest.fn();
mockFn("hello");
expect(mockFn).toHaveBeenCalledWith("hello");



4. Matchers
Matcher
Description
toBe(value)
Exact match
toEqual(obj)
Deep match
toBeNull()
Null check
toBeDefined() / toBeUndefined()
Defined check
toBeTruthy() / toBeFalsy()
Boolean logic
toContain(item)
Array or string contains item
toMatch(regex)
String pattern match
toHaveLength(n)
Array length
toHaveProperty('prop')
Object property check


5. Setup and Teardown
Use for initializing before/after tests:
beforeEach(() => { /* setup */ });
afterEach(() => { /* cleanup */ });
beforeAll(() => { /* once before all tests */ });
afterAll(() => { /* once after all tests */ });

6. Group Tests
Use describe() to group related tests:
describe("Math operations", () => {
  test("adds", () => expect(1 + 1).toBe(2));
  test("subtracts", () => expect(2 - 1).toBe(1));
});

7. Snapshot Testing
import renderer from "react-test-renderer";
import MyComponent from "./MyComponent";
test("matches snapshot", () => {
  const tree = renderer.create(<MyComponent />).toJSON();
  expect(tree).toMatchSnapshot();
});




App.js
// App.js
import React, { useState } from 'react';

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1 data-testid="heading">Counter: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}




App.test.js

// App.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import App from './App';
test('renders initial counter value', () => {
  render(<App />);
  const heading = screen.getByTestId('heading');
  expect(heading).toHaveTextContent('Counter: 0');
});
test('increments the counter when Increment button is clicked', () => {
  render(<App />);
  const incrementButton = screen.getByText('Increment');
  fireEvent.click(incrementButton);
  expect(screen.getByTestId('heading')).toHaveTextContent('Counter: 1');
});
test('resets the counter when Reset button is clicked', () => {
  render(<App />);
  const incrementButton = screen.getByText('Increment');
  const resetButton = screen.getByText('Reset');
  fireEvent.click(incrementButton); // counter = 1
  fireEvent.click(resetButton);     // counter = 0
  expect(screen.getByTestId('heading')).toHaveTextContent('Counter: 0');
});









Mocks Example: App.js

// App.js
import React, { useState } from 'react';
export default function App() {
  const [user, setUser] = useState(null);
  const fetchUser = async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
    const data = await response.json();
    setUser(data);
  };
  return (
    <div>
      <h1>User Info</h1>
      <button onClick={fetchUser}>Load User</button>
      {user && (
        <div>
          <p data-testid="name">Name: {user.name}</p>
          <p data-testid="email">Email: {user.email}</p>
        </div>
      )}
    </div>
  );
}
















Mocks Example: App.test.js

// App.test.js
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import App from './App';
// Mock global fetch before each test
beforeEach(() => {
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ name: 'Alice', email: 'alice@example.com' })
    })
  );
});
// Reset mocks after each test
afterEach(() => {
  jest.resetAllMocks();
});
test('fetches and displays user data', async () => {
  render(<App />);
  const button = screen.getByText('Load User');
  fireEvent.click(button);
  await waitFor(() => {
    expect(screen.getByTestId('name')).toHaveTextContent('Name: Alice');
    expect(screen.getByTestId('email')).toHaveTextContent('Email: alice@example.com');
  });
  expect(fetch).toHaveBeenCalledTimes(1);
  expect(fetch).toHaveBeenCalledWith('https://jsonplaceholder.typicode.com/users/1');
});




























